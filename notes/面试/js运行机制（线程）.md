# js运行机制（线程）

js的关键词：单线程、异步、同步、回调、阻塞等。

## 浏览器线程

* **js运行在浏览器中是单线程的**，即js代码始终在一个线程上执行，该线程被称为js引擎线程。

* **浏览器是多线程的**。

  * js引擎线程：用于执行js任务。（包含一个主线程与若干后台进程。）
  * ui渲染线程： 用于渲染页面
  * 浏览器事件触发线程：用于控制交互，响应用户
  * HTTP请求线程：用于处理请求，Ajax是委托给浏览器新开一个HTTP线程。
  * EventLoop轮询的处理线程：处理用于轮询的消息队列
  * 定时器触发线程

  其中js引擎线程、GUI线程和浏览器事件线程为常驻线程

浏览器中的js任务：

* 执行js代码
* 对用户的输入（鼠标点击、键盘输入等）作出反应
* 处理异步的网络请求



## js单线程

* 单线程即js代码只能在一个线程上执行。js同时只能执行一个任务，其他的任务会排队执行。
* js是单线程的，但是并不代表js引擎线程只有一个。js引擎有多个线程，一个主线程，其他的后台线程配合主线程。
* 多线程之间会共享运行资源，浏览器端的js会操作dom，多个线程必然会带来同步的问题，所有js核心选择了单线程来处理这个问题。**js可以操作dom，影响渲染，所以`js引擎和ui线程是互斥的`。故js执行时会阻塞页面的渲染。**

## 消息队列（任务队列）

js运行时，除了一个运行线程，引擎还提供一个消息队列，里面是各种需要当前程序处理的消息。**新的消息进入队列时，会自动排在队列的尾端。**

* 消息（任务）和回调函数相互联系。

  单线程意味着js任务需要排队，若前一个任务出现大量的耗时操作，后面的任务得不到执行，任务的积累会导致页面的”假死“

## js任务

js任务分为2种：（这里的线程是js引擎主线程）

* 同步任务：在主线程排队支持的任务，前一个任务执行完后，执行后一个任务，形成一个执行栈，（引擎主）线程执行时在内存中形成的空间为栈，进程形成堆结构，这是内存的结构。执行栈可以实现函数的层层调用。**注意不要理解成同步代码进入栈中，按栈的出栈顺序来执行。**
* 异步任务：异步任务将会被主线程挂起，不会进入主线程，而是进入消息队列，而且必须指定回调函数，只有消息队列通知主线程，并且执行栈为空时，该消息对应的任务才会进入执行栈获得执行的机会。

## 【js运行机制】主进程执行的说明：

1. 所有同步任务都在主线程上执行，形成一个执行栈。
2. 主线程外，还存在一个任务队列。只要异步任务有了运行结果，就在”任务队列“之中放置一个事件。
3. 一旦”执行栈“中的所有同步任务执行完毕，系统就会读取任务队列。任务队列中，对应的异步任务结束等待状态，进入执行栈，开始执行。
4. 主线程不断重复（3）

**执行栈中的代码，总是在读取任务队列之前执行**，也即**同步任务总在异步任务之前执行。**



## 事件与回调函数

* 消息队列是一个事件的队列，IO响应时，会往队列中添加一个消息，此时说明相关的异步代码到了执行的实际，可以进入主线程的执行栈了。

* 主线程读取消息队列，可以读取到对应的事件。

* 消息队列可响应IO事件，还有用户产生的事件（如鼠标点击），·**只要指定了回调函数，就会进入消息队列**，等待EventLoop轮询线程处理，是否可以进入主线程执行栈。

* 消息和回调函数相互的联系是：主线程读到消息，就会执行相应的回调函数；进入消息队列的消息，必须对应相应的回调函数，否则这个消息会被丢弃，不会进入消息队列。

* 消息队列是一个先进先出的队列结构，这就决定了其执行顺序，先产生的消息会被主线程先读取，至于会不会执行则会先检查一下执行时间，因为存在setTimeOut等定时函数，这类事件产生的消息进入到消息队列，被执行的实际时机取决于它在队列中的位置和执行时间有关。（将会按照定时的时间排序，比如

  ```js
  setTimeOut(()=>console.log(2),2000);
  setTimeOut(()=>console.log(1),1000);
  //运行结果为 过了1s 输出 1
  //又过了1s 输出 2
  ```

## EventLoop

主线程从消息队列（或任务队列）中读取事件，这个过程循环不断，所以该运行机制也被称为EventLoop（事件循环）。

简单地说，**浏览器的两个线程**：**一个负责程序本身的运行**，称为主线程；**另一个负责主线程与其他进程的通信**，该线程被称为EventLoop线程，即消息进程或事件线程。

js运行在单线程上，所有的浏览器单独开启一个线程来处理事件消息的轮询，避免阻塞js的执行。



### 异步代码执行逻辑

每当遇到I/O的时候，主线程就让EventLoop线程去通知相应的I/O程序，然后接着往后运行，所以不存在等待时间。等待I/O程序完成操作，EventLoop线程把消息添加到消息队列，主线程就调用事先设定的回调函数，完成整个任务。

* 通常把HTTP请求归类为网络IO
* js的Ajax是new XMLHttpRequest()对象实现的，浏览器会新开一个线程来处理http请求，这就是Ajax能够实现局部刷新的同时，还能响应用户交互的原因。



JS引擎线程遇到异步（DOM事件监听、网络请求、setTimeout计时器等...），会交给相应的线程单独去维护异步任务，等待某个时机（计时器结束、网络请求成功、用户点击DOM），然后由 **事件触发线程** 将异步对应的 **回调函数** 加入到消息队列中，消息队列中的回调函数等待被执行。



# 彻底明白JS线程

## 进程与线程

一个进程包含很多个线程。

浏览器包含的线程分类如下：

类别A：GUI渲染线程

类别B：JS引擎线程

类别C：EventLoop轮询处理线程

类别D：其他线程，比如定时器线程、HTTP异步线程、事件线程等。

**因为A、B互斥，即在运行JS时会阻塞渲染，页面渲染时会阻塞js运行。**故BCD之间的关系是重点。

## 类别B：JS引擎线程

称为主线程，即运行JS代码的线程。

主线程运行时，会生成一个执行栈，可以处理函数的嵌套，通过出栈进栈。

### 消息队列

消息队列属于js引擎线程。

可以理解为一个静态的队列存储结构，不是线程，而是一个数据结构，里面存储的是异步成功后的回调函数，最先成功的异步的回调函数在前，后成功的在后。

`注意，是在异步成功后，才把回调函数扔进队列。`

比如`setTimeout( fun, 2000 )`是指该函数在2秒后才进入队列

过程：即，当主线程中运行到setTimeout时，eventloop线程将该异步代码放到定时函数线程中执行，当该异步代码执行成功时，eventloop将函数fun放入消息队列中。



## 类别D：其他线程

主线程中，碰到异步代码，该代码就被放入相应的线程中执行。

setTimeout函数被放到定时器触发进程中；

Ajax被交给HTTP异步线程执行；

onclick被交给事件线程处理。

这些线程的工作有2：

* 执行主线程扔过来的异步代码，并执行代码。
* 保存回调函数，异步执行成功后，通知EventLoop轮询处理线程来取相应的回调函数

## 类别C：eventloop轮询线程

![img](https://upload-images.jianshu.io/upload_images/13253432-d8e6803e58425c10?imageMogr2/auto-orient/strip|imageView2/2/w/550/format/webp)

主线程顺时针看。

`消息和回调函数相互联系`的含义：主线程读到消息，就会执行相应的回调函数；进入消息队列的消息，必须对应相应的回调函数，否则这个消息会被丢弃不会进入消息队列。

所以上图可看作消息队列中是消息或者说事件，一个事件必定含有一个回调函数，所以

`注意：`

1. 整个流程循环往复。
2. **只有主线程的同步代码都执行完了才会执行消息队列里的回调函数。**

