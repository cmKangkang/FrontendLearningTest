# JS事件循环机制 event loop

与js线程结合起来看

![preview](https://pic4.zhimg.com/v2-da078fa3eadf3db4bf455904ae06f84b_r.jpg)

stack表示我们所说的执行栈，web apis则是代表一些异步事件，而callback queue即事件队列(任务队列或消息队列)。

`JS引擎线程遇到异步（DOM事件监听、网络请求、setTimeout计时器等...），会交给相应的线程单独去维护异步任务，等待某个时机（计时器结束、网络请求成功、用户点击DOM），然后由 **事件触发线程** 将异步对应的 **回调函数** 加入到消息队列中，消息队列中的回调函数等待被执行。`



## 宏任务与微任务

在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。

故，`不同异步任务执行的优先级有区别`。

任务队列包含：宏队列与微队列。

JS中，任务被分为两种，宏任务（MacroTask）与微任务（MicroTask）。

宏：

包含，`script`全部代码、`setTimeout`、`setInterval`、`setImmediate`（浏览器暂时不支持，只有IE10支持，具体可见`MDN`）、`I/O`、`UI Rendering`。

微：

`Process.nextTick（Node独有）`、`Promise`、`Object.observe(废弃)`、`MutationObserver`。



## 宏任务与微任务执行机制

1. 执行一个宏任务（栈中没有就从事件队列中获取）
2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
5. 渲染完毕后，JS引擎线程继续，开始下一个宏任务（从宏任务队列中获取）

![img](https://pic2.zhimg.com/v2-d1ca0d6b13501044a5f74c99becbcd3d_b.webp)

![img](https://pic3.zhimg.com/80/v2-d6406cc50f2f5f2c9080101e1f07bd7e_720w.jpg)

### **宏任务和微任务的区别**

- 宏队列可以有多个，微任务队列只有一个,所以每创建一个新的settimeout都是一个新的宏任务队列，执行完一个宏任务队列后，都会去checkpoint 微任务。
- 一个事件循环后，微任务队列执行完了，再执行宏任务队列
- 一个事件循环中，在执行完一个宏队列之后，就会去check 微任务队列

## eventloop

JS有一个主线程和执行栈（调用栈），所有的任务都会被放到执行栈等待主线程运行。

## JS执行栈（调用栈）

采用先进先出 的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完之后，就会从栈顶移出，直至栈被清空。

## 同步任务与异步任务

同步任务会在调用栈中按照顺序等待主线程依次执行。

异步任务会在异步有了结果之后，将注册的回调函数放入消息队列中等待主线程空闲（执行栈为空）时，被读取到栈内等待主线程执行。







