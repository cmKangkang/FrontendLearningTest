事件循环

主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。

简单说，浏览器的两个线程：一个负责程序本身的运行，称为”主线程”；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为”Event Loop线程”（可以译为”消息线程”）。`该线程用于处理消息轮询`

事件循环机制，他会循环监听任务，并在适当的时机取出、执行和释放任务，更新UI等操作，更新UI渲染界面比较耗时，不同的渲染引擎有自己的一套渲染时机逻辑，决定要不要马上执行更新，毕竟更新UI成本大。

``闭包``:闭包特点：1.在一个函数内部定义另外一个函数,并返回内部函数或者立即执行内部函数.2.在内部函数可以读取外部函数定义的局部变量.3.让局部函数的变量始终保存在内存当中.也就是说垃圾回收机制无法回收.
## 异步队列

js执行时有两个异步队列：`宏队列与微队列`，**优先执行微队列中的任务.每次执行完宏队列中的任务后,都会查看微队列中是否有任务.假如有任务则先执行微队列中的任务.再执行宏队列中的任务**.

执行顺序:**微队列->宏队列->微队列->宏队列**.（浏览器会先执行一个宏任务:script）

### 任务队列

宏任务：script（全局任务）, setTimeout, setInterval, setImmediate, I/O, UI rendering.

微任务：process.nextTick, Promise.then, Object.observer, MutationObserver.





## 总结

  1、js中为了防止线程阻塞，阻止全局代码的执行，衍生出很多异步执行解决方案，这些方案都会按需加载到指定的队列中，当全局队列执行完毕后，开始循环从 微队列->宏队列->微队列->宏队列...这种执行顺序执行下去。

  2、当一个宏观队列执行完毕，立刻执行最近添加的微观队列。

  3、这种逻辑也可以为首页加速带来思路。



```js
/*
	模拟
*/
setTimeout(() => {
  console.log('宏队列 11 ');
  setTimeout(() => {
    console.log('宏队列 ' + 111);
  }, 0);
  Promise.resolve(3).then(val => {
    console.log('微队列 ' + val);
  });
}, 0);

setTimeout(() => {
  setTimeout(() => {
    console.log('宏队列 ' + 222);
  }, 6000);
  console.log('宏队列 22 ');
}, 0);

for(let i =1; i <= 5; i++){
  setTimeout(() => {
    console.log('宏队列 ' + i);
    new Promise(res => {
      console.log('promise ' + i);
      res();
    }).then(() => {
      console.log('微队列 ' + i);
    })
  }, i * 1000);

  console.log('宏队列 script ' + i);
}

Promise.resolve(1).then(val => {
  console.log('微队列 ' + val);
})

Promise.resolve(2).then(val => {
  console.log('微队列 ' + val);
})

/**
	以上代码得到控制台输出如下：
	
	宏队列 script 1
    宏队列 script 2
    宏队列 script 3
    宏队列 script 4
    宏队列 script 5
    微队列 1
    微队列 2
    宏队列 11 
    微队列 3
    宏队列 22 
    宏队列 111
    宏队列 1
    promise 1
    微队列 1
    宏队列 2
    promise 2
    微队列 2
    宏队列 3
    promise 3
    微队列 3
    宏队列 4
    promise 4
    微队列 4
    宏队列 5
    promise 5
    微队列 5
    宏队列 222

	推测法则如下：
	1. 执行时，会将代码扫描一遍，且扫描时，先执行全局队列的script，即未被setTimeout\Promise等包含的代码，把微任务依次放入微队列，宏任务依次放入宏队列。（一层一层拨开）
	2. 全局script执行完后，将执行微队列内的任务，待微队列为空后，执行宏队列内的任务。若微队列任务的代码中含有全局script代码，则先执行宏代码，再执行微任务；若微队列任务的代码中含有宏任务代码，则将宏任务依次放入宏队列，等待执行。
	3. 当微队列为空后，执行宏队列内的代码。遇到微任务则将该任务放入队列并执行微队列内的任务。回到2.
*/
```

推测法则如下：

1. 执行时，会将代码扫描一遍，且扫描时，先执行全局队列的script，即未被setTimeout\Promise等包含的代码，把微任务依次放入微队列，宏任务依次放入宏队列。（一层一层拨开）
2. 全局script执行完后，将执行微队列内的任务，待微队列为空后，执行宏队列内的任务。若微队列任务的代码中含有全局script代码，则先执行宏代码，再执行微任务；若微队列任务的代码中含有宏任务代码，则将宏任务依次放入宏队列，等待执行。
3. 当微队列为空后，执行宏队列内的代码。遇到微任务则将该任务放入队列并执行微队列内的任务。回到2.

