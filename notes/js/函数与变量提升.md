# 函数

核心内容：

- 函数有哪几种定义和调用方式
- this：函数内部的 this 指向、如何改变 this 的指向。
- 函数的严格模式
- 高阶函数：函数作为参数传递、函数作为返回值传递
- 闭包：闭包的作用
- 递归：递归的两个条件
- 深拷贝和浅拷贝的区别

## 函数

函数：对一些功能或语句进行封装，通过调用的形式，执行这些语句。

函数也是一个对象，typeof 检查时返回function

**函数的作用**：将大量重复的语句抽取出来，写在函数里，以后需要这些语句的时候，可以直接调用函数，避免重复劳动；简化编程，让编程模块化。高内聚、低耦合。

## 函数的定义声明

1. 利用关键字自定义函数（命名函数）

2. 函数表达式（匿名函数）

3. 使用构造函数

   ```js
   var 变量名/函数名  = new Function('形参1', '形参2', '函数体');
   //注意，Function 里面的参数都必须是字符串格式。也就是说，形参也必须放在字符串里；函数体也是放在字符串里包裹起来，放在 Function 的最后一个参数的位置。
   ```

## 总结：

1. **所有的函数，都是 `Fuction` 的“实例”**（或者说是“实例对象”）。函数本质上都是通过 new Function 得到的。
2. **函数也属于“对象”**。



## 函数的调用

方式1：普通函数的调用。

* 函数名();

* 函数名.call()；

  ```js
  fn2.call();
  ```

方式2：通过对象的方法来调用

```js
var obj = {
	a: 'qianguyihao',
	fn2: function() {
		console.log('千古壹号，永不止步!');
	},
};

obj.fn2(); // 调用函数
```

方式3：立即执行函数

```js
(function() {
	console.log('我是立即执行函数');
})();
```

方式4：通过构造函数来调用

```js
function Fun3() {
	console.log('千古壹号，永不止步~');
}

new Fun3();
```

方式5：绑定事件函数

```js
var btn = document.getElementById('btn');
            //2.绑定事件
            btn.onclick = function() {
                console.log('点击按钮后，要做的事情');
            };
```

方式6：定时器函数

```js
  let num = 1;
   setInterval(function () {
       num ++;
       console.log(num);
   }, 1000);
```



## 函数名、函数体和函数加载问题（重要，请记住）

**函数名==整个函数**

```js
console.log(fn) == console.log(function fn(){alert(1)});

//定义fn方法
function fn(){
	alert(1)
};
```

**函数的加载问题**：JS加载的时候，只加载函数名，不加载函数体。所以如果想使用内部的成员变量，需要调用函数。

### fn() 和 fn 的区别【重要】

`fn()`：调用函数。调用之后，还获取了函数的返回值.

`fn`：函数对象。相当于直接获取了整个函数对象。

```js
function fn(){
    return "hello";
}
typeof fn;//function
typeof fn();//string
```



## 变量的声明提前（变量提升）

使用var关键字声明的变量（ 比如 `var a = 1`），**会在所有的代码执行之前被声明**（但是不会赋值），但是如果声明变量时不是用var关键字（比如直接写`a = 1`），则变量不会被声明提前。

```js
console.log(a);//undefined
var a = 123;
```

```js
console.log(a);//报错，Uncaught ReferenceError: a is not defined
a = 123;   //此时a相当于window.a
```

```js
a = 123;   //此时a相当于window.a
console.log(a);//123
```

```js
foo();

function foo() {
    if (false) {
        var i = 123;
    }
    console.log(i);//undefined
}
//注意，打印结果并没有报错，而是 undefined。这个例子，再次说明了：变量 i 在函数执行前，就被提前声明了，只是尚未被赋值。
```

## 函数的提前声明

* **函数声明**创建的函数`function fn(){}`，**会被提前**。

  ```js
  fn();  // 虽然 函数 fn1 的定义是在后面，但是因为被提前声明了， 所以此处可以调用函数
  
  function fn() {
      console.log('我是函数 fn1');
  }
  ```

* **函数表达式**创建的函数`var fn = function(){}`，**不会被声明提前**，所以**不能在声明前调用**。

  很好理解，由变量提升规则可知，此时仅fn被声明提升，为undefined，但并未赋值（未把function赋值给fn).



## 预编译

js运行三部曲：语法分析、预编译、解释执行。

**规律1**：**任何变量，如果未经声明就赋值，此变量是属于 window 的属性**，而且不会做变量提升。（注意，无论在哪个作用域内赋值）

**规律2：一切声明的全局变量，全是window的属性**。

```js
function foo() {
    var a = b = 100; // 连续赋值
}

foo();

console.log(window.b); // 在全局范围内访问 b
console.log(b); // 在全局范围内访问 b，但是前面没有加 window 这个关键字

console.log(window.a); // 在全局范围内访问 a
console.log(a); // 在全局范围内访问 a，但是前面没有加 window 这个关键字
/*==================解释如下====================*/
/*
当执行了foo()函数之后， var a = b = 100 这行连续赋值的代码等价于 var a = (b = 100)，其执行顺序是：

（1）先把 100 赋值给 b；

（2）再声明变量 a；

（3）再把 b 的值赋值给 a。

我们可以看到，b 是未经声明的变量就被赋值了，此时，根据规律1，这个 b 是属于 window.b；而 a 的作用域仅限于 foo() 函数内部，不属于 window。所以也就有了这样的打印结果。
*/
```

### 函数预编译的步骤

> 函数预编译，发生在函数执行的前一刻。

（1）创建AO对象。AO即 Activation Object 活跃对象，其实就是「执行期上下文」。

（2）找形参和变量声明，将形参名和变量作为 AO 的属性名，值为undefined。

（3）将实参值和形参统一，实参的值赋给形参。

（4）查找函数声明，函数名作为 AO 对象的属性名，值为整个函数体。